# Function to create log directory if it doesn't exist
function Initialize-LogDirectory {
    if (-not (Test-Path -Path $logDirectory -PathType Container)) {
        New-Item -Path $logDirectory -ItemType Directory | Out-Null
    }
}
param (
    [string]$pfxFilePath,
    [string]$pfxPassword,
    [string]$certStoreLocation = "LocalMachine",
    [string]$certStoreName = "My"
)

# Import the PFX certificate with private key
$cert = Import-PfxCertificate -FilePath $pfxFilePath -CertStoreLocation $certStoreLocation -CertStoreName $certStoreName -Password (ConvertTo-SecureString -String $pfxPassword -AsPlainText -Force)

# Check if the certificate was imported successfully
if ($cert -ne $null) {
    Write-Host "Certificate successfully imported:"
    Write-Host "Thumbprint: $($cert.Thumbprint)"
    Write-Host "Subject: $($cert.Subject)"
} else {
    Write-Host "Failed to import the certificate."
}

function Check-HTTPStatusAlternative {
    param (
        [string]$url,
        [string]$username,
        [string]$password
    )

    try {
        # Create a credential object
        $credential = New-Object -TypeName PSCredential -ArgumentList $username, (ConvertTo-SecureString -String $password -AsPlainText -Force)

        # Create headers with Authorization Basic
        $headers = @{
            'Authorization' = 'Basic ' + [Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes("$($credential.UserName):$($credential.GetNetworkCredential().Password)"))
        }

        # Send a request and retrieve the HTTP response
        $response = Invoke-RestMethod -Uri $url -Method Head -Headers $headers

        # Check if the HTTP status code is 200 (OK)
        if ($response.StatusCode -eq 200) {
            Write-Host "HTTP Status: 200 (OK)"
        } else {
            Write-Host "HTTP Status: $($response.StatusCode) $($response.StatusDescription)"
        }
    } catch {
        Write-Host "Error: $_"
    }
}

# Example Usage:
# Check-HTTPStatusAlternative -url "https://example.com" -username "yourUsername" -password "yourPassword"

param (
    [string]$serverName,
    [string]$siteName,
    [int]$port
)

# Set the log directory and log file path
$logDirectory = "C:\Path\To\Log\Directory"
$logFileName = "script_log.txt"
$logFilePath = Join-Path -Path $logDirectory -ChildPath $logFileName

# Function to write log entries
function Write-Log {
    param (
        [string]$logEntry
    )

    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntryWithTimestamp = "$timestamp - $logEntry"
    Add-Content -Path $logFilePath -Value $logEntryWithTimestamp
}

# Check if the server is accessible
$pingResult = Test-Connection -ComputerName $serverName -Count 2 -Quiet

if (-not $pingResult) {
    $errorMessage = "Server '$serverName' is not accessible. Exiting script."
    Write-Log -logEntry $errorMessage
    Write-Host $errorMessage
    exit
}

# Check if the IIS site exists
$iisSite = Get-Website -Name $siteName -ErrorAction SilentlyContinue

if ($iisSite -eq $null) {
    $errorMessage = "IIS site '$siteName' not found on server '$serverName'. Exiting script."
    Write-Log -logEntry $errorMessage
    Write-Host $errorMessage
    exit
}

# Get the existing binding
$existingBinding = Get-WebBinding -Name $siteName -Port $port

if ($existingBinding -eq $null) {
    $errorMessage = "Binding not available for site '$siteName' on port $port. Exiting script."
    Write-Log -logEntry $errorMessage
    Write-Host $errorMessage
    exit
}

# Rest of your script logic
# ...

# Log success message
$successMessage = "Binding information retrieved successfully for site '$siteName' on server '$serverName' and port $port."
Write-Log -logEntry $successMessage
Write-Host $successMessage

# Set variables
$siteName = "YourSiteName"  # Replace with your actual site name
$certThumbprint = "YourCertThumbprint"  # Replace with the thumbprint of your new SSL certificate

# Set the path to your .cer file
$cerFilePath = "C:\Path\To\Your\Certificate.cer"  # Replace with the actual path to your .cer file

# Get the thumbprint of the .cer file
$thumbprint = (Get-FileHash -Path $cerFilePath -Algorithm SHA1).Hash

Write-Host "Thumbprint of the .cer file: $thumbprint"

# Get the site by name
$site = Get-WebSite -Name $siteName

# Get the certificate by thumbprint
$cert = Get-Item Cert:\LocalMachine\My\$certThumbprint

# Get the existing binding
$binding = $site.Bindings | Where-Object { $_.Protocol -eq "https" }

# Update the binding with the new certificate
$binding.AddSslCertificate($cert.GetCertHash(), "My")

# Commit the changes
$site | Set-WebSite -Force

Write-Host "SSL certificate updated for $siteName"


# Set variables
$siteName = "YourSiteName"  # Replace with your actual site name
$certThumbprint = "YourCertThumbprint"  # Replace with the thumbprint of your new SSL certificate

# Get the site by name
$site = Get-WebSite -Name $siteName

# Get the existing binding
$existingBinding = Get-WebBinding -Name $siteName -Port 443

# Remove the existing binding
Remove-WebBinding -Name $siteName -Port 443 -Protocol "https"

# Create a new binding with the updated certificate
New-WebBinding -Name $siteName -Port 443 -Protocol "https" -HostHeader $existingBinding.HostHeader -SslFlags 1  # Use SslFlags 1 for SNI SSL

# Set the SSL certificate for the new binding
Set-WebBinding -Name $siteName -Port 443 -PropertyName "CertificateHash" -Value $certThumbprint

Write-Host "SSL certificate updated for $siteName"

# Set variables
$siteName = "YourSiteName"        # Replace with your actual site name
$certThumbprint = "YourCertThumbprint"  # Replace with the thumbprint of your new SSL certificate
$ipAddress = "YourIPAddress"      # Replace with the desired IP address

# Get the site by name
$site = Get-WebSite -Name $siteName

# Get the existing binding
$existingBinding = Get-WebBinding -Name $siteName -Port 443

# Remove the existing binding
Remove-WebBinding -Name $siteName -Port 443 -Protocol "https"

# Create a new binding with the updated certificate and specified IP address
New-WebBinding -Name $siteName -IPAddress $ipAddress -Port 443 -Protocol "https" -HostHeader $existingBinding.HostHeader -SslFlags 1

# Set the SSL certificate for the new binding
Set-WebBinding -Name $siteName -IPAddress $ipAddress -Port 443 -Protocol "https" -PropertyName "CertificateHash" -Value $certThumbprint

Write-Host "SSL certificate updated for $siteName with IP address $ipAddress"

# Set variables
$siteName = "YourSiteName"  # Replace with your actual site name

# Get the site by name
$site = Get-WebSite -Name $siteName

# Get the existing binding
$existingBinding = Get-WebBinding -Name $siteName -Port 443

# Extract IP address from BindingInformation
$ipAddress = $existingBinding.BindingInformation -split ":")[0]

Write-Host "IP address for $siteName binding: $ipAddress"
# Set variables
$siteName = "YourSiteName"  # Replace with your actual site name
$port = 443  # Replace with the port of your HTTPS binding

# Get the existing binding
$existingBinding = Get-WebBinding -Name $siteName -Port $port

# Get the certificate thumbprint from the binding
$thumbprint = (Get-Item -Path "Cert:\LocalMachine\My\$($existingBinding.CertificateHash)").Thumbprint

Write-Host "Thumbprint of the existing certificate for $siteName: $thumbprint"

# Set variables
$siteName = "YourSiteName"  # Replace with your actual site name
$port = 443  # Replace with the port of your HTTPS binding

# Get the existing binding
$existingBinding = Get-WebBinding -Name $siteName -Port $port

# Get the certificate thumbprint from the binding
$thumbprint = $existingBinding.CertificateHash
$cert = Get-Item -Path "Cert:\LocalMachine\My\$thumbprint"

# Get the expiration date of the certificate
$expirationDate = $cert.NotAfter

Write-Host "Expiration date of the certificate for $siteName: $expirationDate"

# Set variables
$certificatePath = "C:\Path\To\Your\Certificate.pfx"  # Replace with the path to your PFX certificate file
$certificatePassword = "YourCertificatePassword"  # Replace with the password for your PFX certificate

# Import the certificate
$cert = Import-PfxCertificate -FilePath $certificatePath -CertStoreLocation Cert:\LocalMachine\My -Password (ConvertTo-SecureString -String $certificatePassword -AsPlainText -Force)

# Get the thumbprint of the imported certificate
$thumbprint = $cert.Thumbprint

Write-Host "Thumbprint of the imported certificate: $thumbprint"

# Set variables
$certificatePath = "C:\Path\To\Your\Certificate.pfx"  # Replace with the path to your PFX certificate file
$certificatePassword = "YourCertificatePassword"  # Replace with the password for your PFX certificate

# Import the certificate
$cert = Import-PfxCertificate -FilePath $certificatePath -CertStoreLocation Cert:\LocalMachine\My -Password (ConvertTo-SecureString -String $certificatePassword -AsPlainText -Force)

# Get the thumbprint of the imported certificate
$thumbprint = $cert.Thumbprint

# Set variables
$siteName = "YourSiteName"  # Replace with your actual site name
$port = 443  # Replace with the port of your HTTPS binding
$expectedThumbprint = "YourExpectedThumbprint"  # Replace with the expected thumbprint of your new SSL certificate

# Get the existing binding
$existingBinding = Get-WebBinding -Name $siteName -Port $port

# Get the certificate thumbprint from the binding
$thumbprint = $existingBinding.CertificateHash

# Check if the thumbprint matches the expected value
if ($thumbprint -eq $expectedThumbprint) {
    Write-Host "The site $siteName is updated with the latest SSL certificate."
} else {
    Write-Host "The site $siteName does not have the expected SSL certificate. Current thumbprint: $thumbprint"
}
Write-Host "Thumbprint of the imported certificate: $thumbprint"

# Set variables
$siteUrl = "https://yourwebsite.com"  # Replace with the URL of your web service
$expectedThumbprint = "YourExpectedThumbprint"  # Replace with the expected thumbprint of your new SSL certificate

# Check if the service is running
$serviceStatus = Test-NetConnection -ComputerName $siteUrl -Port 443
if ($serviceStatus.TcpTestSucceeded) {
    Write-Host "Web service at $siteUrl is running."
} else {
    Write-Host "Web service at $siteUrl is not running or not reachable."
}

# Set variables
$thumbprint = "YourExistingThumbprint"  # Replace with the thumbprint of your existing SSL certificate
$backupPath = "C:\Path\To\Backup\CertificateBackup.pfx"  # Replace with the path where you want to save the backup

# Export the certificate without a password
Export-PfxCertificate -Cert Cert:\LocalMachine\My\$thumbprint -FilePath $backupPath -NoExportPrivateKey

Write-Host "Backup of the certificate with thumbprint $thumbprint (without password) is created at $backupPath"
# Check if the SSL certificate is updated
try {
    $response = Invoke-WebRequest -Uri $siteUrl -UseBasicParsing
    $thumbprint = $response.Headers['X-SSL-Cert']
    
    if ($thumbprint -eq $expectedThumbprint) {
        Write-Host "The SSL certificate for $siteUrl is updated with the latest certificate."
    } else {
        Write-Host "The SSL certificate for $siteUrl does not match the expected thumbprint. Current thumbprint: $thumbprint"
    }
} catch {
    Write-Host "Error connecting to $siteUrl. $_"
}
# Set variables
$thumbprint = "YourExistingThumbprint"  # Replace with the thumbprint of your existing SSL certificate
$backupPath = "C:\Path\To\Backup\CertificateBackup.pfx"  # Replace with the path where you want to save the backup

# Export the certificate without a password
Export-PfxCertificate -Cert Cert:\LocalMachine\My\$thumbprint -FilePath $backupPath -NoExportPrivateKey

Write-Host "Backup of the certificate with thumbprint $thumbprint (without password) is created at $backupPath"



# Set variables
$thumbprint = "YourExistingThumbprint"  # Replace with the thumbprint of your existing SSL certificate
$backupPath = "C:\Path\To\Backup\CertificateBackup.pfx"  # Replace with the path where you want to save the backup
$backupPassword = "YourBackupPassword"  # Replace with a strong password for the backup

# Export the certificate
Export-PfxCertificate -Cert Cert:\LocalMachine\My\$thumbprint -FilePath $backupPath -Password (ConvertTo-SecureString -String $backupPassword -AsPlainText -Force)

Write-Host "Backup of the certificate with thumbprint $thumbprint is created at $backupPath"

function Restart-IISWithCheck {
    # Restart IIS
    Restart-Service -Name "W3SVC" -Force

    # Check if IIS is running after restart
    $iisStatus = Get-Service -Name "W3SVC" | Select-Object -ExpandProperty Status

    if ($iisStatus -eq 'Running') {
        Write-Host "IIS restarted successfully."
    } else {
        # If IIS is not running, try starting it
        Start-Service -Name "W3SVC"

        # Check again if IIS is running
        $iisStatusAfterStart = Get-Service -Name "W3SVC" | Select-Object -ExpandProperty Status

        if ($iisStatusAfterStart -eq 'Running') {
            Write-Host "IIS started successfully after restart attempt."
        } else {
            # If IIS is still not running, throw an error
            throw "Failed to restart or start IIS. Check IIS configuration and try again."
        }
    }
}

# Example usage
try {
    Restart-IISWithCheck
} catch {
    Write-Host "Error: $_"
}

# URL to the HTTPS endpoint
$url = "https://example.com"

try {
    # Send a request and retrieve the SSL certificate
    $response = Invoke-WebRequest -Uri $url -Method Head -UseDefaultCredentials

    # Extract the SSL thumbprint from the response headers
    $thumbprint = $response.Headers['X-SSL-Cert']

    if ($thumbprint) {
        Write-Host "SSL thumbprint: $thumbprint"
    } else {
        Write-Host "SSL thumbprint not found in response headers."
    }
} catch {
    Write-Host "Error: $_"
}

function Check-SSLCertificateExpiration {
    param (
        [string]$siteName,
        [int]$port
    )

    # Get the existing binding
    $existingBinding = Get-WebBinding -Name $siteName -Port $port

    if ($existingBinding -eq $null) {
        Write-Host "Site binding not found."
        return
    }

    # Get the certificate thumbprint from the binding
    $thumbprint = $existingBinding.CertificateHash
    $cert = Get-Item -Path "Cert:\LocalMachine\My\$thumbprint"

    # Calculate the number of days until the certificate expires
    $daysUntilExpiration = ($cert.NotAfter - (Get-Date)).Days

    if ($daysUntilExpiration -lt 60) {
        # Notify user (replace with your notification mechanism)
        Write-Host "SSL certificate for $siteName on port $port is going to expire in $daysUntilExpiration days. Consider renewing or updating the certificate."

        # You can include additional notification methods here (e.g., sending an email)
        # Example: Send-MailMessage -To "your@email.com" -From "script@server.com" -Subject "SSL Certificate Expiration Alert" -Body "SSL certificate for $siteName on port $port is going to expire in $daysUntilExpiration days." -SmtpServer "your-smtp-server.com"
    } else {
        Write-Host "SSL certificate for $siteName on port $port is not expiring soon."
    }
}

# Example Usage:
# Check-SSLCertificateExpiration -siteName "YourSiteName" -port 443

function Check-HTTPStatus {
    param (
        [string]$url
    )

    try {
        # Send a request and retrieve the HTTP response
        $response = Invoke-WebRequest -Uri $url -Method Head

        # Check if the HTTP status code is 200 (OK)
        if ($response.StatusCode -eq 200) {
            Write-Host "HTTP Status: 200 (OK)"
        } else {
            Write-Host "HTTP Status: $($response.StatusCode) $($response.StatusDescription)"
        }
    } catch {
        Write-Host "Error: $_"
    }
}

# Example Usage:
# Check-HTTPStatus -url "https://example.com"

function Check-HTTPStatusAlternative {
    param (
        [string]$url
    )

    try {
        # Create a request object
        $request = [System.Net.HttpWebRequest]::Create($url)
        $request.Method = "HEAD"

        # Get the response
        $response = $request.GetResponse()

        # Check if the HTTP status code is 200 (OK)
        if ($response.StatusCode -eq [System.Net.HttpStatusCode]::OK) {
            Write-Host "HTTP Status: 200 (OK)"
        } else {
            Write-Host "HTTP Status: $($response.StatusCode) $($response.StatusDescription)"
        }
    } catch {
        Write-Host "Error: $_"
    } finally {
        # Close the response
        if ($response -ne $null) {
            $response.Close()
        }
    }
}

# Example Usage:
# Check-HTTPStatusAlternative -url "https://example.com"
# Example of remote execution using PowerShell Remoting
$remoteServer = "YourServerNameOrIPAddress"

# Script content
$scriptContent = @"
# Your SSL renewal script content here
"@

# Invoke the script remotely
Invoke-Command -ComputerName $remoteServer -ScriptBlock {
    param($scriptContent)
    Invoke-Expression $scriptContent
} -ArgumentList $scriptContent

[
    {"ServerName": "Server1", "Port": 443, "CertificatePath": "C:\Path\To\Cert1.pfx"},
    {"ServerName": "Server2", "Port": 8443, "CertificatePath": "C:\Path\To\Cert2.pfx"}
    // Add more server entries as needed
]

# Read server information from JSON
$servers = Get-Content -Raw -Path "C:\Path\To\servers.json" | ConvertFrom-Json

# Iterate through servers
foreach ($server in $servers) {
    $siteName = $server.ServerName
    $port = $server.Port
    $certPath = $server.CertificatePath

    # Check SSL expiration and renew if needed
    Check-And-Renew-SSLCertificate -siteName $siteName -port $port -certPath $certPath
}
# Configuration for the website and email
$websiteUrl = "http://your-iis-site.com"
$emailFrom = "your-email@your-domain.com"
$emailTo = "recipient@example.com"
$emailSubject = "IIS Site Screenshot"
$emailBody = "Please find the attached screenshot of the IIS site."

# Specify the path to save the screenshot
$screenshotPath = "C:\Path\To\screenshot.png"

# Create Internet Explorer COM object
$ie = New-Object -ComObject InternetExplorer.Application

# Navigate to the website
$ie.Navigate($websiteUrl)

# Wait for the page to load (adjust sleep time as needed)
Start-Sleep -Seconds 5

# Capture screenshot
$ie.Document.body.createControlRange() | foreach-object { $_.execCommand("Copy", $false, $null) }
Add-Type -AssemblyName System.Windows.Forms
[System.Windows.Forms.Clipboard]::GetImage().Save($screenshotPath)

# Quit Internet Explorer
$ie.Quit()

# Send email with the screenshot as an attachment
Send-MailMessage -From $emailFrom -To $emailTo -Subject $emailSubject -Body $emailBody -Attachments $screenshotPath -SmtpServer "smtp.your-email-provider.com"
