# Import the WebAdministration module
Import-Module WebAdministration

# Get all IIS sites
$iisSites = Get-Website

# Iterate through each IIS site
foreach ($site in $iisSites) {
    Write-Host "Site Name: $($site.Name)"
    
    # Get all bindings for the site
    $bindings = Get-WebBinding -Name $site.Name
    
    # Iterate through each binding
    foreach ($binding in $bindings) {
        $certificateThumbprint = $binding.CertificateThumbprint
        
        # If a certificate is associated with the binding
        if ($certificateThumbprint) {
            # Get the certificate details
            $certificate = Get-ChildItem -Path "Cert:\LocalMachine\My" | Where-Object {$_.Thumbprint -eq $certificateThumbprint}
            
            if ($certificate) {
                Write-Host "  Binding Information: $($binding.Protocol) $($binding.BindingInformation)"
                Write-Host "  Certificate Issued To: $($certificate.Subject)"
            } else {
                Write-Host "  Certificate not found for Thumbprint: $certificateThumbprint"
            }
        } else {
            Write-Host "  No certificate associated with $($binding.Protocol) $($binding.BindingInformation)"
        }
    }
}


# Get all IIS sites
$iisSites = Get-IISSite

# Iterate through each IIS site
foreach ($site in $iisSites) {
    Write-Host "Site Name: $($site.Name)"
    
    # Get all bindings for the site
    $bindings = $site.Bindings.Collection
    
    # Iterate through each binding
    foreach ($binding in $bindings) {
        $certificateThumbprint = $binding.CertificateThumbprint
        
        # If a certificate is associated with the binding
        if ($certificateThumbprint) {
            # Get the certificate details
            $certificate = Get-ChildItem -Path "Cert:\LocalMachine\My" | Where-Object {$_.Thumbprint -eq $certificateThumbprint}
            
            if ($certificate) {
                Write-Host "  Binding Information: $($binding.Protocol) $($binding.BindingInformation)"
                Write-Host "  Certificate Issued To: $($certificate.Subject)"
            } else {
                Write-Host "  Certificate not found for Thumbprint: $certificateThumbprint"
            }
        } else {
            Write-Host "  No certificate associated with $($binding.Protocol) $($binding.BindingInformation)"
        }
    }
}

# Path to the input PEM file
$inputPemFilePath = "path/to/input.pem"

# Read the content of the input PEM file
$pemContent = Get-Content -Path $inputPemFilePath -Raw

# Split the content into individual certificate sections
$certSections = $pemContent -split "(?<=-----END CERTIFICATE-----\r?\n)"

# Iterate through each certificate section
foreach ($certSection in $certSections) {
    # Check if the section contains a certificate
    if ($certSection -match "(?ms)(?<=-----BEGIN CERTIFICATE-----\r?\n)(.*?)(?=\r?\n-----END CERTIFICATE-----)") {
        # Extract the certificate content
        $certContent = $matches[1]

        # Extract the subject from the certificate
        if ($certSection -match "Subject=(.*?)\r?\n") {
            $subject = $matches[1]
            
            # Define the output file path based on the subject
            $outputFilePath = "path/to/output/$subject.pem"

            # Write the certificate content to the output file
            Set-Content -Path $outputFilePath -Value "Subject=$subject`n$certContent" -Encoding ASCII
        }
    }
}


function Restart-IISAndWait {
    # Restart IIS
    Restart-Service -Name "W3SVC" -Force

    # Check the status every 10 seconds until it's started
    do {
        # Wait for 10 seconds
        Start-Sleep -Seconds 10

        # Get the status of IIS
        $status = Get-Service -Name "W3SVC" | Select-Object -ExpandProperty Status

        # Check if the status is 'Running'
        if ($status -eq 'Running') {
            Write-Host "IIS has started successfully."
            return
        } else {
            Write-Host "Waiting for IIS to start..."
        }
    } while ($true)  # Infinite loop until IIS is started
}

# Call the function to restart IIS and wait for it to start
Restart-IISAndWait

function Verify-Certificate {
    param (
        [string]$keyStorePath,
        [string]$mainCertificatePath
    )

    # Extract thumbprint and expiry date from the exported main certificate
    $exportedMainCertificate = Get-Item $mainCertificatePath
    $exportedThumbprint = (Get-ChildItem $mainCertificatePath).Thumbprint
    $exportedExpiryDate = $exportedMainCertificate.NotAfter

    # Get the main certificate from the keystore
    $keytoolPath = "C:\path\to\keytool\keytool.exe"
    $keyStorePassword = "your_keystore_password_here"
    $alias = "your_alias_here"

    $mainCertificateInfo = & $keytoolPath -list -keystore $keyStorePath -storepass $keyStorePassword -alias $alias -rfc
    $mainCertificateInfo | Out-String -Stream | ForEach-Object {
        if ($_ -match "Alias name: $alias") {
            $thumbprint = ($_ -split ':')[1].Trim()
        }
        if ($_ -match "Valid from: (.+) until: (.+)") {
            $expiryDate = [datetime]::ParseExact(($matches[2]), "MMM dd HH:mm:ss yyyy", $null)
        }
    }

    # Compare thumbprints and expiry dates
    if ($exportedThumbprint -eq $thumbprint) {
        Write-Host "Thumbprint verification: Match"
    } else {
        Write-Host "Thumbprint verification: No match"
    }

    if ($exportedExpiryDate -eq $expiryDate) {
        Write-Host "Expiry date verification: Match"
    } else {
        Write-Host "Expiry date verification: No match"
    }
}


# Define the path to the ISKeystore.jks file
$keyStorePath = "C:\path\to\ISKeystore.jks"

# Check if ISKeystore.jks file exists
if (Test-Path $keyStorePath) {
    # Generate a timestamp for renaming
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"

    # Rename the existing ISKeystore.jks file with a timestamp
    $backupKeyStorePath = "C:\path\to\ISKeystore_$timestamp.jks"
    Rename-Item -Path $keyStorePath -NewName $backupKeyStorePath

    Write-Host "Existing ISKeystore.jks file renamed to: $backupKeyStorePath"
}

# Import all exported certificates into ISKeystore.jks file
$keytoolPath = "C:\path\to\keytool\keytool.exe"
$keyStorePassword = "your_keystore_password_here"
$alias = "your_alias_here"

foreach ($certPath in $certificatesToImport) {
    & $keytoolPath -importcert -keystore $keyStorePath -storepass $keyStorePassword -file $certPath -alias $alias -noprompt
}

# Output confirmation message
Write-Host "Certificates imported into ISKeystore.jks successfully."

# Define the path to the PKCS#7 certificate
$pkcs7CertificatePath = "C:\path\to\your\pkcs7_certificate.p7b"

# Import the PKCS#7 certificate
$pkcs7Certificate = Import-PfxCertificate -FilePath $pkcs7CertificatePath -CertStoreLocation Cert:\CurrentUser\My

# Export the root certificate
$rootCertificate = Get-ChildItem Cert:\LocalMachine\Root | Where-Object {$_.Thumbprint -eq $pkcs7Certificate.Issuer}
$rootCertificatePath = "C:\path\to\export\root_certificate.cer"
$rootCertificate | Export-Certificate -FilePath $rootCertificatePath -Type CERT

# Export the intermediate certificate
$intermediateCertificate = Get-ChildItem Cert:\LocalMachine\CA | Where-Object {$_.Thumbprint -eq $pkcs7Certificate.Thumbprint}
$intermediateCertificatePath = "C:\path\to\export\intermediate_certificate.cer"
$intermediateCertificate | Export-Certificate -FilePath $intermediateCertificatePath -Type CERT

# Export the original main certificate
$mainCertificatePath = "C:\path\to\export\main_certificate.cer"
$pkcs7Certificate | Export-Certificate -FilePath $mainCertificatePath -Type CERT

# Output confirmation messages
Write-Host "Root certificate exported to: $rootCertificatePath"
Write-Host "Intermediate certificate exported to: $intermediateCertificatePath"
Write-Host "Main certificate exported to: $mainCertificatePath"

# Combine all exported certificates into a single PKCS#12 file
$certificatesToImport = @($rootCertificatePath, $intermediateCertificatePath, $mainCertificatePath)
$combinedCertificatePath = "C:\path\to\export\combined_certificates.pfx"
Get-ChildItem $certificatesToImport | Export-PfxCertificate -FilePath $combinedCertificatePath -Password (ConvertTo-SecureString -String "your_password_here" -AsPlainText -Force)

# Import all exported certificates into ISKeystore.jks file
$keytoolPath = "C:\path\to\keytool\keytool.exe"
$keyStorePath = "C:\path\to\ISKeystore.jks"
$keyStorePassword = "your_keystore_password_here"
$alias = "your_alias_here"

foreach ($certPath in $certificatesToImport) {
    & $keytoolPath -importcert -keystore $keyStorePath -storepass $keyStorePassword -file $certPath -alias $alias -noprompt
}

# Output confirmation message
Write-Host "Certificates imported into ISKeystore.jks successfully."


# Define the path to the PKCS#7 certificate
$pkcs7CertificatePath = "C:\path\to\your\pkcs7_certificate.p7b"

# Import the PKCS#7 certificate
$pkcs7Certificate = Import-PfxCertificate -FilePath $pkcs7CertificatePath -CertStoreLocation Cert:\CurrentUser\My

# Export the root and intermediate certificates
$rootCertificate = Get-ChildItem Cert:\LocalMachine\Root | Where-Object {$_.Thumbprint -eq $pkcs7Certificate.Issuer}
$intermediateCertificate = Get-ChildItem Cert:\LocalMachine\CA | Where-Object {$_.Thumbprint -eq $pkcs7Certificate.Thumbprint}

# Define the path to export the certificates
$exportPath = "C:\path\to\export\folder"

# Export the root certificate
$rootCertificatePath = Join-Path -Path $exportPath -ChildPath "root_certificate.cer"
$rootCertificate | Export-Certificate -FilePath $rootCertificatePath -Type CERT

# Export the intermediate certificate
$intermediateCertificatePath = Join-Path -Path $exportPath -ChildPath "intermediate_certificate.cer"
$intermediateCertificate | Export-Certificate -FilePath $intermediateCertificatePath -Type CERT

# Output confirmation messages
Write-Host "Root certificate exported to: $rootCertificatePath"
Write-Host "Intermediate certificate exported to: $intermediateCertificatePath"

# Copy the exported certificates to a specified path
$destinationPath = "C:\path\to\destination\folder"
Copy-Item -Path $rootCertificatePath -Destination $destinationPath
Copy-Item -Path $intermediateCertificatePath -Destination $destinationPath

# Output confirmation message
Write-Host "Certificates copied to: $destinationPath"
function Send-EmailOnADAccountIssues {
    param (
        [string]$Username,
        [string]$To,
        [string]$From,
        [string]$SMTPServer,
        [string]$SMTPUsername,
        [string]$SMTPPassword
    )

    # Initialize an array to collect failure messages
    $FailureMessages = @()

    # Check if password never expires is false
    $User = Get-ADUser -Identity $Username -Properties PasswordNeverExpires
    if (-not $User.PasswordNeverExpires) {
        $FailureMessages += "Password for user $Username expires and needs attention."
    }

    # Check if the account is locked out
    if ($User.LockedOut) {
        $FailureMessages += "Account $Username is locked out."
    }

    # Check if password expired is true
    $PasswordExpired = [bool](Get-ADUserResultantPasswordPolicy $Username).PasswordExpired
    if ($PasswordExpired) {
        $FailureMessages += "Password for user $Username has expired."
    }

    # Check when the account was last changed
    $WhenChanged = $User.whenChanged
    $Today = Get-Date
    $SevenDaysAgo = $Today.AddDays(-7)
    if ($WhenChanged -lt $SevenDaysAgo) {
        $FailureMessages += "Account $Username was not changed within the last 7 days."
    }

    # Send email if there are failure messages
    if ($FailureMessages.Count -gt 0) {
        $Subject = "AD Account Issues for $Username"
        $Body = "The following issues were found with the AD account for $Username:`n`n" + ($FailureMessages -join "`n") 

        Send-MailMessage -From $From -To $To -Subject $Subject -Body $Body -SmtpServer $SMTPServer -Credential (New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $SMTPUsername, (ConvertTo-SecureString -String $SMTPPassword -AsPlainText -Force)) -UseSsl
    }
}

# Usage example:
Send-EmailOnADAccountIssues -Username "exampleuser" -To "recipient@example.com" -From "sender@example.com" -SMTPServer "smtp.example.com" -SMTPUsername "your-smtp-username" -SMTPPassword "your-smtp-password"

function Send-EmailOnADAccountIssues {
    param (
        [string]$Username,
        [string]$To,
        [string]$From,
        [string]$SMTPServer,
        [string]$SMTPUsername,
        [string]$SMTPPassword
    )

    # Initialize an array to collect failure messages
    $FailureMessages = @()

    # Check if password never expires is false
    $User = Get-ADUser -Identity $Username -Properties PasswordNeverExpires
    if (-not $User.PasswordNeverExpires) {
        $FailureMessages += "Password for user $Username expires and needs attention."
    }

    # Check if the account is locked out
    if ($User.LockedOut) {
        $FailureMessages += "Account $Username is locked out."
    }

    # Check if password expired is true
    $PasswordExpired = [bool](Get-ADUserResultantPasswordPolicy $Username).PasswordExpired
    if ($PasswordExpired) {
        $FailureMessages += "Password for user $Username has expired."
    }

    # Send email if there are failure messages
    if ($FailureMessages.Count -gt 0) {
        $Subject = "AD Account Issues for $Username"
        $Body = "The following issues were found with the AD account for $Username:`n`n" + ($FailureMessages -join "`n") 

        Send-MailMessage -From $From -To $To -Subject $Subject -Body $Body -SmtpServer $SMTPServer -Credential (New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $SMTPUsername, (ConvertTo-SecureString -String $SMTPPassword -AsPlainText -Force)) -UseSsl
    }
}

# Usage example:
Send-EmailOnADAccountIssues -Username "exampleuser" -To "recipient@example.com" -From "sender@example.com" -SMTPServer "smtp.example.com" -SMTPUsername "your-smtp-username" -SMTPPassword "your-smtp-password"

function Get-UserPasswordInfo {
    param (
        [string]$ADAccountName,
        [string]$ServerName
    )

    try {
        # Get AD user information
        $user = Get-ADUser -Identity $ADAccountName -Server $ServerName -Properties "PasswordNeverExpires", "PasswordExpired", "CannotChangePassword" -ErrorAction Stop

        # Check if password not required
        if ($user.CannotChangePassword -eq $true) {
            Write-Host "Password not required for $ADAccountName on $ServerName"
            return
        }

        # Check if password never expires
        if ($user.PasswordNeverExpires -eq $true) {
            Write-Host "Password never expires for $ADAccountName on $ServerName"
            return
        }

        # Check if password is expired
        if ($user.PasswordExpired -eq $true) {
            Write-Host "Password expired for $ADAccountName on $ServerName"
        } else {
            $expiryDate = $user."msDS-UserPasswordExpiryTimeComputed"
            $expiryDate = [datetime]::FromFileTime($expiryDate)
            Write-Host "Password will expire on $expiryDate for $ADAccountName on $ServerName"
        }
    } catch {
        Write-Host "Error retrieving AD user information for $ADAccountName on $ServerName: $_"
    }
}

# Read the CSV file
$csvPath = "C:\Path\To\Your\File.csv"
$accounts = Import-Csv $csvPath

# Iterate through each entry in the CSV
foreach ($account in $accounts) {
    # Call the function
    Get-UserPasswordInfo -ADAccountName $account.ADAccountName -ServerName $account.ServerName
}

Write-Host "Script completed."


# Read the CSV file
$csvPath = "C:\Path\To\Your\File.csv"
$accounts = Import-Csv $csvPath

# Iterate through each entry in the CSV
foreach ($account in $accounts) {
    # Get AD user information
    $user = Get-ADUser -Identity $account.ADAccountName -Server $account.ServerName -Properties "PasswordNeverExpires", "PasswordExpired", "CannotChangePassword"

    # Check if password not required
    if ($user.CannotChangePassword -eq $true) {
        Write-Host "Password not required for $($account.ADUserAccount) on $($account.ServerName)"
        break
    }

    # Check if password never expires
    if ($user.PasswordNeverExpires -eq $true) {
        Write-Host "Password never expires for $($account.ADUserAccount) on $($account.ServerName)"
        break
    }

    # Check if password is expired
    if ($user.PasswordExpired -eq $true) {
        Write-Host "Password expired for $($account.ADUserAccount) on $($account.ServerName)"
    } else {
        $expiryDate = $user."msDS-UserPasswordExpiryTimeComputed"
        $expiryDate = [datetime]::FromFileTime($expiryDate)
        Write-Host "Password will expire on $expiryDate for $($account.ADUserAccount) on $($account.ServerName)"
    }
}

When installing SSL certificates via PowerShell scripts, various error scenarios can occur. Here are some common error scenarios to be aware of:

1. **Invalid Certificate Format:**
   - Error: PowerShell may encounter issues if the certificate file format is incorrect or corrupted.
   - Solution: Ensure that the certificate file is in the correct format (e.g., PEM, PFX) and verify its integrity.

2. **Insufficient Permissions:**
   - Error: The script may fail if the user running the PowerShell script lacks the necessary permissions to install certificates.
   - Solution: Run the script with an account that has the required permissions to install certificates on the target system.

3. **Certificate Already Exists:**
   - Error: Attempting to install a certificate with a name that already exists in the certificate store can lead to errors.
   - Solution: Check for the existence of the certificate before installation or handle certificate name conflicts appropriately.

4. **Private Key Mismatch:**
   - Error: The private key associated with the certificate may not match during installation, leading to errors.
   - Solution: Ensure that the private key corresponds to the certificate being installed, and they are part of the same certificate file.

5. **Invalid Certificate Chain:**
   - Error: Issues may arise if the certificate chain is incomplete or contains invalid certificates.
   - Solution: Validate the certificate chain and ensure that all necessary intermediate and root certificates are included.

6. **Expired Certificate:**
   - Error: Attempting to install an expired certificate will result in an error.
   - Solution: Regularly check and renew certificates before they expire, and implement monitoring to alert when certificates are close to expiration.

7. **Revoked Certificate:**
   - Error: A certificate that has been revoked may cause issues during installation.
   - Solution: Check the certificate's revocation status before installation, and update revoked certificates accordingly.

8. **Network Issues:**
   - Error: If the script relies on external services (e.g., Certificate Authorities) and encounters network issues, it may fail.
   - Solution: Implement error handling for network-related issues and ensure proper connectivity to external services.

9. **Incorrect Certificate Store:**
   - Error: Installing the certificate in the wrong certificate store can lead to issues when services or applications try to access it.
   - Solution: Specify the correct certificate store during installation to ensure it is available for the intended use.

10. **Firewall or Security Software Interference:**
    - Error: Security software or firewalls may interfere with the certificate installation process.
    - Solution: Temporarily disable or configure security software to allow the certificate installation process.

Handling these potential error scenarios in your PowerShell script will contribute to a more robust and reliable SSL certificate installation process.
# Example values, replace these with your actual values
$siteName = ""
$certPath = "xyz"

# Define an array of variables to validate
$variablesToValidate = @("siteName", "certPath")

# Initialize an empty variable to store the error message
$errorMessages = @()

# Validate each variable
foreach ($variable in $variablesToValidate) {
    try {
        $value = Get-Variable -Name $variable -ValueOnly -ErrorAction Stop
        if ([string]::IsNullOrEmpty($value)) {
            $errorMessage = "$variable must be provided and cannot be empty."
            Write-Host $errorMessage
            # Add the error message to the variable
            $errorMessages += $errorMessage
        }
    } catch {
        $errorMessage = "$variable not found or has a null value."
        Write-Host $errorMessage
        # Add the error message to the variable
        $errorMessages += $errorMessage
    }
}

# If there are errors, display and log them
if ($errorMessages.Count -gt 0) {
    Write-Error "Validation failed. Exiting script."
    $errorMessages | ForEach-Object {
        Write-Error $_
    }
    exit
}

# If validation passes, proceed with other functions
# Function 1: Validate siteName and certPath
# Function 2: ...

# Example: Display values if validation passes
foreach ($variable in $variablesToValidate) {
    Write-Host "$variable: $(Get-Variable -Name $variable -ValueOnly)"
}

# Rest of your script logic...



# Replace 'C:\Path\To\Your\ReadableCertificate.pfx' with the path to your readable PFX file
$readablePfxFilePath = 'C:\Path\To\Your\ReadableCertificate.pfx'

# Replace 'C:\Path\To\Your\BinaryCertificate.pfx' with the path where you want to save the binary PFX file
$binaryPfxFilePath = 'C:\Path\To\Your\BinaryCertificate.pfx'

# Read the readable PFX file and convert to a binary PFX file
(Get-Content -Path $readablePfxFilePath -Raw) | ForEach-Object {
    [System.Convert]::FromBase64String($_)
} | Set-Content -Path $binaryPfxFilePath -Encoding Byte

Write-Host "Binary PFX file saved to: $binaryPfxFilePath"

# Function to create log directory if it doesn't exist
function Initialize-LogDirectory {
    if (-not (Test-Path -Path $logDirectory -PathType Container)) {
        New-Item -Path $logDirectory -ItemType Directory | Out-Null
    }
}
param (
    [string]$pfxFilePath,
    [string]$pfxPassword,
    [string]$certStoreLocation = "LocalMachine",
    [string]$certStoreName = "My"
)

# Import the PFX certificate with private key
$cert = Import-PfxCertificate -FilePath $pfxFilePath -CertStoreLocation $certStoreLocation -CertStoreName $certStoreName -Password (ConvertTo-SecureString -String $pfxPassword -AsPlainText -Force)

# Check if the certificate was imported successfully
if ($cert -ne $null) {
    Write-Host "Certificate successfully imported:"
    Write-Host "Thumbprint: $($cert.Thumbprint)"
    Write-Host "Subject: $($cert.Subject)"
} else {
    Write-Host "Failed to import the certificate."
}

function Check-HTTPStatusAlternative {
    param (
        [string]$url,
        [string]$username,
        [string]$password
    )

    try {
        # Create a credential object
        $credential = New-Object -TypeName PSCredential -ArgumentList $username, (ConvertTo-SecureString -String $password -AsPlainText -Force)

        # Create headers with Authorization Basic
        $headers = @{
            'Authorization' = 'Basic ' + [Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes("$($credential.UserName):$($credential.GetNetworkCredential().Password)"))
        }

        # Send a request and retrieve the HTTP response
        $response = Invoke-RestMethod -Uri $url -Method Head -Headers $headers

        # Check if the HTTP status code is 200 (OK)
        if ($response.StatusCode -eq 200) {
            Write-Host "HTTP Status: 200 (OK)"
        } else {
            Write-Host "HTTP Status: $($response.StatusCode) $($response.StatusDescription)"
        }
    } catch {
        Write-Host "Error: $_"
    }
}

# Example Usage:
# Check-HTTPStatusAlternative -url "https://example.com" -username "yourUsername" -password "yourPassword"

param (
    [string]$serverName,
    [string]$siteName,
    [int]$port
)

# Set the log directory and log file path
$logDirectory = "C:\Path\To\Log\Directory"
$logFileName = "script_log.txt"
$logFilePath = Join-Path -Path $logDirectory -ChildPath $logFileName

# Function to write log entries
function Write-Log {
    param (
        [string]$logEntry
    )

    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntryWithTimestamp = "$timestamp - $logEntry"
    Add-Content -Path $logFilePath -Value $logEntryWithTimestamp
}

# Check if the server is accessible
$pingResult = Test-Connection -ComputerName $serverName -Count 2 -Quiet

if (-not $pingResult) {
    $errorMessage = "Server '$serverName' is not accessible. Exiting script."
    Write-Log -logEntry $errorMessage
    Write-Host $errorMessage
    exit
}

# Check if the IIS site exists
$iisSite = Get-Website -Name $siteName -ErrorAction SilentlyContinue

if ($iisSite -eq $null) {
    $errorMessage = "IIS site '$siteName' not found on server '$serverName'. Exiting script."
    Write-Log -logEntry $errorMessage
    Write-Host $errorMessage
    exit
}

# Get the existing binding
$existingBinding = Get-WebBinding -Name $siteName -Port $port

if ($existingBinding -eq $null) {
    $errorMessage = "Binding not available for site '$siteName' on port $port. Exiting script."
    Write-Log -logEntry $errorMessage
    Write-Host $errorMessage
    exit
}

# Rest of your script logic
# ...

# Log success message
$successMessage = "Binding information retrieved successfully for site '$siteName' on server '$serverName' and port $port."
Write-Log -logEntry $successMessage
Write-Host $successMessage

# Set variables
$siteName = "YourSiteName"  # Replace with your actual site name
$certThumbprint = "YourCertThumbprint"  # Replace with the thumbprint of your new SSL certificate

# Set the path to your .cer file
$cerFilePath = "C:\Path\To\Your\Certificate.cer"  # Replace with the actual path to your .cer file

# Get the thumbprint of the .cer file
$thumbprint = (Get-FileHash -Path $cerFilePath -Algorithm SHA1).Hash

Write-Host "Thumbprint of the .cer file: $thumbprint"

# Get the site by name
$site = Get-WebSite -Name $siteName

# Get the certificate by thumbprint
$cert = Get-Item Cert:\LocalMachine\My\$certThumbprint

# Get the existing binding
$binding = $site.Bindings | Where-Object { $_.Protocol -eq "https" }

# Update the binding with the new certificate
$binding.AddSslCertificate($cert.GetCertHash(), "My")

# Commit the changes
$site | Set-WebSite -Force

Write-Host "SSL certificate updated for $siteName"


# Set variables
$siteName = "YourSiteName"  # Replace with your actual site name
$certThumbprint = "YourCertThumbprint"  # Replace with the thumbprint of your new SSL certificate

# Get the site by name
$site = Get-WebSite -Name $siteName

# Get the existing binding
$existingBinding = Get-WebBinding -Name $siteName -Port 443

# Remove the existing binding
Remove-WebBinding -Name $siteName -Port 443 -Protocol "https"

# Create a new binding with the updated certificate
New-WebBinding -Name $siteName -Port 443 -Protocol "https" -HostHeader $existingBinding.HostHeader -SslFlags 1  # Use SslFlags 1 for SNI SSL

# Set the SSL certificate for the new binding
Set-WebBinding -Name $siteName -Port 443 -PropertyName "CertificateHash" -Value $certThumbprint

Write-Host "SSL certificate updated for $siteName"

# Set variables
$siteName = "YourSiteName"        # Replace with your actual site name
$certThumbprint = "YourCertThumbprint"  # Replace with the thumbprint of your new SSL certificate
$ipAddress = "YourIPAddress"      # Replace with the desired IP address

# Get the site by name
$site = Get-WebSite -Name $siteName

# Get the existing binding
$existingBinding = Get-WebBinding -Name $siteName -Port 443

# Remove the existing binding
Remove-WebBinding -Name $siteName -Port 443 -Protocol "https"

# Create a new binding with the updated certificate and specified IP address
New-WebBinding -Name $siteName -IPAddress $ipAddress -Port 443 -Protocol "https" -HostHeader $existingBinding.HostHeader -SslFlags 1

# Set the SSL certificate for the new binding
Set-WebBinding -Name $siteName -IPAddress $ipAddress -Port 443 -Protocol "https" -PropertyName "CertificateHash" -Value $certThumbprint

Write-Host "SSL certificate updated for $siteName with IP address $ipAddress"

# Set variables
$siteName = "YourSiteName"  # Replace with your actual site name

# Get the site by name
$site = Get-WebSite -Name $siteName

# Get the existing binding
$existingBinding = Get-WebBinding -Name $siteName -Port 443

# Extract IP address from BindingInformation
$ipAddress = $existingBinding.BindingInformation -split ":")[0]

Write-Host "IP address for $siteName binding: $ipAddress"
# Set variables
$siteName = "YourSiteName"  # Replace with your actual site name
$port = 443  # Replace with the port of your HTTPS binding

# Get the existing binding
$existingBinding = Get-WebBinding -Name $siteName -Port $port

# Get the certificate thumbprint from the binding
$thumbprint = (Get-Item -Path "Cert:\LocalMachine\My\$($existingBinding.CertificateHash)").Thumbprint

Write-Host "Thumbprint of the existing certificate for $siteName: $thumbprint"

# Set variables
$siteName = "YourSiteName"  # Replace with your actual site name
$port = 443  # Replace with the port of your HTTPS binding

# Get the existing binding
$existingBinding = Get-WebBinding -Name $siteName -Port $port

# Get the certificate thumbprint from the binding
$thumbprint = $existingBinding.CertificateHash
$cert = Get-Item -Path "Cert:\LocalMachine\My\$thumbprint"

# Get the expiration date of the certificate
$expirationDate = $cert.NotAfter

Write-Host "Expiration date of the certificate for $siteName: $expirationDate"

# Set variables
$certificatePath = "C:\Path\To\Your\Certificate.pfx"  # Replace with the path to your PFX certificate file
$certificatePassword = "YourCertificatePassword"  # Replace with the password for your PFX certificate

# Import the certificate
$cert = Import-PfxCertificate -FilePath $certificatePath -CertStoreLocation Cert:\LocalMachine\My -Password (ConvertTo-SecureString -String $certificatePassword -AsPlainText -Force)

# Get the thumbprint of the imported certificate
$thumbprint = $cert.Thumbprint

Write-Host "Thumbprint of the imported certificate: $thumbprint"

# Set variables
$certificatePath = "C:\Path\To\Your\Certificate.pfx"  # Replace with the path to your PFX certificate file
$certificatePassword = "YourCertificatePassword"  # Replace with the password for your PFX certificate

# Import the certificate
$cert = Import-PfxCertificate -FilePath $certificatePath -CertStoreLocation Cert:\LocalMachine\My -Password (ConvertTo-SecureString -String $certificatePassword -AsPlainText -Force)

# Get the thumbprint of the imported certificate
$thumbprint = $cert.Thumbprint

# Set variables
$siteName = "YourSiteName"  # Replace with your actual site name
$port = 443  # Replace with the port of your HTTPS binding
$expectedThumbprint = "YourExpectedThumbprint"  # Replace with the expected thumbprint of your new SSL certificate

# Get the existing binding
$existingBinding = Get-WebBinding -Name $siteName -Port $port

# Get the certificate thumbprint from the binding
$thumbprint = $existingBinding.CertificateHash

# Check if the thumbprint matches the expected value
if ($thumbprint -eq $expectedThumbprint) {
    Write-Host "The site $siteName is updated with the latest SSL certificate."
} else {
    Write-Host "The site $siteName does not have the expected SSL certificate. Current thumbprint: $thumbprint"
}
Write-Host "Thumbprint of the imported certificate: $thumbprint"

# Set variables
$siteUrl = "https://yourwebsite.com"  # Replace with the URL of your web service
$expectedThumbprint = "YourExpectedThumbprint"  # Replace with the expected thumbprint of your new SSL certificate

# Check if the service is running
$serviceStatus = Test-NetConnection -ComputerName $siteUrl -Port 443
if ($serviceStatus.TcpTestSucceeded) {
    Write-Host "Web service at $siteUrl is running."
} else {
    Write-Host "Web service at $siteUrl is not running or not reachable."
}

# Set variables
$thumbprint = "YourExistingThumbprint"  # Replace with the thumbprint of your existing SSL certificate
$backupPath = "C:\Path\To\Backup\CertificateBackup.pfx"  # Replace with the path where you want to save the backup

# Export the certificate without a password
Export-PfxCertificate -Cert Cert:\LocalMachine\My\$thumbprint -FilePath $backupPath -NoExportPrivateKey

Write-Host "Backup of the certificate with thumbprint $thumbprint (without password) is created at $backupPath"
# Check if the SSL certificate is updated
try {
    $response = Invoke-WebRequest -Uri $siteUrl -UseBasicParsing
    $thumbprint = $response.Headers['X-SSL-Cert']
    
    if ($thumbprint -eq $expectedThumbprint) {
        Write-Host "The SSL certificate for $siteUrl is updated with the latest certificate."
    } else {
        Write-Host "The SSL certificate for $siteUrl does not match the expected thumbprint. Current thumbprint: $thumbprint"
    }
} catch {
    Write-Host "Error connecting to $siteUrl. $_"
}
# Set variables
$thumbprint = "YourExistingThumbprint"  # Replace with the thumbprint of your existing SSL certificate
$backupPath = "C:\Path\To\Backup\CertificateBackup.pfx"  # Replace with the path where you want to save the backup

# Export the certificate without a password
Export-PfxCertificate -Cert Cert:\LocalMachine\My\$thumbprint -FilePath $backupPath -NoExportPrivateKey

Write-Host "Backup of the certificate with thumbprint $thumbprint (without password) is created at $backupPath"



# Set variables
$thumbprint = "YourExistingThumbprint"  # Replace with the thumbprint of your existing SSL certificate
$backupPath = "C:\Path\To\Backup\CertificateBackup.pfx"  # Replace with the path where you want to save the backup
$backupPassword = "YourBackupPassword"  # Replace with a strong password for the backup

# Export the certificate
Export-PfxCertificate -Cert Cert:\LocalMachine\My\$thumbprint -FilePath $backupPath -Password (ConvertTo-SecureString -String $backupPassword -AsPlainText -Force)

Write-Host "Backup of the certificate with thumbprint $thumbprint is created at $backupPath"

function Restart-IISWithCheck {
    # Restart IIS
    Restart-Service -Name "W3SVC" -Force

    # Check if IIS is running after restart
    $iisStatus = Get-Service -Name "W3SVC" | Select-Object -ExpandProperty Status

    if ($iisStatus -eq 'Running') {
        Write-Host "IIS restarted successfully."
    } else {
        # If IIS is not running, try starting it
        Start-Service -Name "W3SVC"

        # Check again if IIS is running
        $iisStatusAfterStart = Get-Service -Name "W3SVC" | Select-Object -ExpandProperty Status

        if ($iisStatusAfterStart -eq 'Running') {
            Write-Host "IIS started successfully after restart attempt."
        } else {
            # If IIS is still not running, throw an error
            throw "Failed to restart or start IIS. Check IIS configuration and try again."
        }
    }
}

# Example usage
try {
    Restart-IISWithCheck
} catch {
    Write-Host "Error: $_"
}

# URL to the HTTPS endpoint
$url = "https://example.com"

try {
    # Send a request and retrieve the SSL certificate
    $response = Invoke-WebRequest -Uri $url -Method Head -UseDefaultCredentials

    # Extract the SSL thumbprint from the response headers
    $thumbprint = $response.Headers['X-SSL-Cert']

    if ($thumbprint) {
        Write-Host "SSL thumbprint: $thumbprint"
    } else {
        Write-Host "SSL thumbprint not found in response headers."
    }
} catch {
    Write-Host "Error: $_"
}

function Check-SSLCertificateExpiration {
    param (
        [string]$siteName,
        [int]$port
    )

    # Get the existing binding
    $existingBinding = Get-WebBinding -Name $siteName -Port $port

    if ($existingBinding -eq $null) {
        Write-Host "Site binding not found."
        return
    }

    # Get the certificate thumbprint from the binding
    $thumbprint = $existingBinding.CertificateHash
    $cert = Get-Item -Path "Cert:\LocalMachine\My\$thumbprint"

    # Calculate the number of days until the certificate expires
    $daysUntilExpiration = ($cert.NotAfter - (Get-Date)).Days

    if ($daysUntilExpiration -lt 60) {
        # Notify user (replace with your notification mechanism)
        Write-Host "SSL certificate for $siteName on port $port is going to expire in $daysUntilExpiration days. Consider renewing or updating the certificate."

        # You can include additional notification methods here (e.g., sending an email)
        # Example: Send-MailMessage -To "your@email.com" -From "script@server.com" -Subject "SSL Certificate Expiration Alert" -Body "SSL certificate for $siteName on port $port is going to expire in $daysUntilExpiration days." -SmtpServer "your-smtp-server.com"
    } else {
        Write-Host "SSL certificate for $siteName on port $port is not expiring soon."
    }
}

# Example Usage:
# Check-SSLCertificateExpiration -siteName "YourSiteName" -port 443

function Check-HTTPStatus {
    param (
        [string]$url
    )

    try {
        # Send a request and retrieve the HTTP response
        $response = Invoke-WebRequest -Uri $url -Method Head

        # Check if the HTTP status code is 200 (OK)
        if ($response.StatusCode -eq 200) {
            Write-Host "HTTP Status: 200 (OK)"
        } else {
            Write-Host "HTTP Status: $($response.StatusCode) $($response.StatusDescription)"
        }
    } catch {
        Write-Host "Error: $_"
    }
}

# Example Usage:
# Check-HTTPStatus -url "https://example.com"

function Check-HTTPStatusAlternative {
    param (
        [string]$url
    )

    try {
        # Create a request object
        $request = [System.Net.HttpWebRequest]::Create($url)
        $request.Method = "HEAD"

        # Get the response
        $response = $request.GetResponse()

        # Check if the HTTP status code is 200 (OK)
        if ($response.StatusCode -eq [System.Net.HttpStatusCode]::OK) {
            Write-Host "HTTP Status: 200 (OK)"
        } else {
            Write-Host "HTTP Status: $($response.StatusCode) $($response.StatusDescription)"
        }
    } catch {
        Write-Host "Error: $_"
    } finally {
        # Close the response
        if ($response -ne $null) {
            $response.Close()
        }
    }
}

# Example Usage:
# Check-HTTPStatusAlternative -url "https://example.com"
# Example of remote execution using PowerShell Remoting
$remoteServer = "YourServerNameOrIPAddress"

# Script content
$scriptContent = @"
# Your SSL renewal script content here
"@

# Invoke the script remotely
Invoke-Command -ComputerName $remoteServer -ScriptBlock {
    param($scriptContent)
    Invoke-Expression $scriptContent
} -ArgumentList $scriptContent

[
    {"ServerName": "Server1", "Port": 443, "CertificatePath": "C:\Path\To\Cert1.pfx"},
    {"ServerName": "Server2", "Port": 8443, "CertificatePath": "C:\Path\To\Cert2.pfx"}
    // Add more server entries as needed
]

# Read server information from JSON
$servers = Get-Content -Raw -Path "C:\Path\To\servers.json" | ConvertFrom-Json

# Iterate through servers
foreach ($server in $servers) {
    $siteName = $server.ServerName
    $port = $server.Port
    $certPath = $server.CertificatePath

    # Check SSL expiration and renew if needed
    Check-And-Renew-SSLCertificate -siteName $siteName -port $port -certPath $certPath
}
# Configuration for the website and email
$websiteUrl = "http://your-iis-site.com"
$emailFrom = "your-email@your-domain.com"
$emailTo = "recipient@example.com"
$emailSubject = "IIS Site Screenshot"
$emailBody = "Please find the attached screenshot of the IIS site."

# Specify the path to save the screenshot
$screenshotPath = "C:\Path\To\screenshot.png"

# Create Internet Explorer COM object
$ie = New-Object -ComObject InternetExplorer.Application

# Navigate to the website
$ie.Navigate($websiteUrl)

# Wait for the page to load (adjust sleep time as needed)
Start-Sleep -Seconds 5

# Capture screenshot
$ie.Document.body.createControlRange() | foreach-object { $_.execCommand("Copy", $false, $null) }
Add-Type -AssemblyName System.Windows.Forms
[System.Windows.Forms.Clipboard]::GetImage().Save($screenshotPath)

# Quit Internet Explorer
$ie.Quit()

# Send email with the screenshot as an attachment
Send-MailMessage -From $emailFrom -To $emailTo -Subject $emailSubject -Body $emailBody -Attachments $screenshotPath -SmtpServer "smtp.your-email-provider.com"
